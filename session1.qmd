---
title: 'Session 1: tidyverse essentials dplyr & tidyr'
author: "Antonio Huerta Montellano"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
editor_options: 
  markdown: 
    wrap: 72
---

Borrar todas las variables, funciones u objetos guardados en memoria.
Asimismo, se cierran todas las ventanas abiertas de gráficas.

```{r}
rm(list = ls()) # Borra todos los objetos (variables, funciones, etc.) que hay en el entorno de trabajo actual
# ls() enlista todos los objetos que se han creado en la sesión actual
graphics.off() # Cierra todas las ventanas gráficas abiertas
```

El siguiente código corresponde a un chunk en el que se establecen las
configuraciones del script, así como las librerías que importarán.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Cargar librerías
library(dplyr)
library(tidyr)
library(DT)
library(ggplot2)
```

A lo largo de esta sesión se empleará una base precargada en `R` llamada
*mpg*. Esta base contiene datos sobre distintos modelos de automóviles
lanzados al mercado entre el año 1999 y 2008, con la función
`help("mpg")` se pude obtener las descripción técnica de esta base.

```{r}
# Almacenar base en otro objeto, llamado df
df <-  mpg
View(df) # Ver tabla
print(df) # Imprimir tabla en consola
str(df) # Estructura de la tabla, también sirve para ver la estructura de culaquier objeto o función en R.
cat("Filas de la tabla: ",nrow(df),"\n") # Filas de la tabla
cat("Columnas de la tabla: ",ncol(df)) # Columnas de la tabla
```

## 1.3 Manipular variables (columns) - select(), rename()

### select() - Selección de columnas

Esta función permite seleccionar las columnas de la tabla que le
indiquemos. Por ejemplo, extraer las siguientes columnas:
*manufacturar*, *model* y *year*.

```{r}
select(df, manufacturer, model, year)

# df %>% select(manufacturer,model,year)
```

También se puede guardar la selección en una nueva tabla.

```{r}
df.car.info <- select(df, manufacturer, model, year)
head(df.car.info)
rm(df.car.info)
```

Se puede indicar con `select()` que se seleccionen todas las columnas,
excepto algunas escribiendo "*-*" antes del nombre de la columna. Por
ejemplo, quitemos la columna *year* y guardemos el resultado en un nuevo
dataframe.

```{r}
df.no.year <-  select(df, -year)
head(df.no.year)
rm(df.no.year)
```

Si queremos mandar una columna al final de la tabla se puede hacer,
poniendo el signo "*-*" antes de la columna y, dentro del mismo
`select()`, escribir solo el nombre de la columna. Por ejemplo, mandemos
al final de la tabla la columna *model*.

```{r}
select(df, -model,model)

# Es equivalente al siguiente código:
# df %>% select(-model,model)
```

#### Starts_with

Selecciona todas las columnas que empiecen con la cadena de texto
indicada. Por ejemplo, seleccionar todas las columnas que empiezan con
la letra *m*.

```{r}
select(df,starts_with("m"))
```

#### Contains

Selecciona todas las columnas que contienen la cadena de texto indicada.
Por ejemplo, seleccionar todas las columnas que contienen la letra *r*.

```{r}
select(df, contains("r"))
```

#### Ends_with

Selecciona todas las columnas que terminen con la cadena de texto
indicada. Por ejemplo, seleccionar todas las columnas que terminan con
la letra *y*.

```{r}
select(df,ends_with("y"))
```

#### Combinaciones

Se pueden combinar las instrucciones anteriores para seleccionar
columnas bajo criterios más específicos.

Seleccionar las columnas que empiezan con "c" y terminan "y":

```{r}
select(df, starts_with("c") & ends_with("y"))
```

Seleccionar las columnas que empiezan con "c" o terminan "y":

```{r}
select(df, starts_with("c"),ends_with("y"))
```

Seleccionar la columna *class* y las columnas que contengan la letra
"r":

```{r}
select(df,class,ends_with("r"))
```

#### Seleccionar por índice

Se puede seleccionar distintos conjuntos de columnas de acuerdo a los
índices que se señalen.

```{r}
select(df,4)
```

Seleccionar de las columnas 2 a la 4 (se tiene que sumar una unidad a la
última fila):

```{r}
select(df, 2:4)
```

Seleccionar las columnas 2, 5 y 7:

```{r}
select(df,c(2,5,7))
```

Seleccionar las últimas cuatro columnas:

```{r}
select(df,(ncol(df)-3):ncol(df))
#select(df, 8:11)
```

También se pueden combinar las instrucciones de selección que se han
visto para la función `select()`. Por ejemplo, seleccionar las columnas
que comienzan con *m* de las primeras cuatro columnas, extraer la
columna *hwy* y seleccionar las columnas con índice 4 y 7:

```{r}
select(df,1:4 & starts_with("m"), hwy, c(4,7))
```

Quitar columnas por medio de un vector:

```{r}
select(df, -all_of(c("hwy","year")))
```

### rename() - Renombrar columnas

Esta función permite cambiar el nombre de las columnas de la tabla que
se le indique. Por ejemplo, renombrar *manufacturer* por *mnfc* y
*model* por *mod*:

```{r}
rename(df,
       mnfc = manufacturer,
       mod = model)
```

También se puede renombrar al momento de seleccionar las columnas con
`select()`. Repetir lo anterior con este método al seleccionar esas
columnas:

```{r}
select(df,
       mnfc = manufacturer,
       mod = model,
       everything()) 

select(df, manufacturer,model, everything()) %>%
  rename(
    mnfc = manufacturer,
    mod = model
  )
```

`everything()` indica a la función `select()` que después de las
columnas *mnfc* y *mod* van el resto de columnas de la tabla *df*. La
función `select()` también permite reordenar las columnas

## 1.4 mutate(), transmute()

### mutate() - Crear nuevas variables

Esta función permite construir nuevas columnas en la tabla; por defecto,
las nuevas columnas se encuentran hasta la derecha de la tabla, es
decir, poseen los últimos índices de la columna. Por ejemplo, calcular
los galones por milla promedio entre la carretera y la ciudad,

```{r}
df <- mutate(
  df,
  `avg miles per galon` = (cty + hwy)/2
  )
print(df)
```

Crear una columna que indique el nombre del *manufacturador* y *modelo*
(columna *car*) y otra que muestre los cilindros y transmisión en una
sola fila (columna *cyl / trans*):

```{r}
df <- mutate(
  df,
  car = paste(manufacturer,model, sep=" "),
  `cyl / trans` = paste(cyl, " cilindros", "/", trans, " transmisión", sep=""),
  year_model = paste0(model,year)
  )
print(df)
```

### transmute() - Crea nuevas variables y borra el resto

Esta función es parecida a `mutate()` puesto que crea nuevas columnas en
la tabla, pero se diferencia en que `transmutate()` solo regresa las
nuevas columnas que se construyeron con esta función. Por ejemplo, se
repiten los ejemplos hechos con `mutate()`:

```{r}
transmute(
  df,
  `avg miles per gallon` = (cty + hwy)/2
)
```

```{r}
transmute(
  df,
  car = paste(manufacturer, model, sep = " "),
  `cyl / trans` = paste(cyl, " cilindros", " / ", trans, " transmisión", sep = "")
)
```

Se reinicia la base a como estaba en un inicio para los siguientes temas

```{r}
# Reiniciar la data
df <- mpg
```

## 1.5 Casos de manipulación (filas) - filter(), slice()

### filter() - Extraer filas bajo condiciones

La función `filter()` permite filtrar las filas de una tabla que cumplan
la condición, con respecto a sus columnas, que se indiquen en sus
parámetros. Por ejemplo, filtrar las columnas donde el modelo haya sido
manufacturado por *Audi*:

```{r}
filter(df, manufacturer == "audi")

# df %>% filter(manufacturer == "audi")
```

Filtrar aquellos modelos cuyas millas de autopista por galón sean
mayores a $30\text{mi}/\text{gal}$:

```{r}
filter(df, hwy >= 30)
```

Filtrar los modelos que no hayan sido manufacturados en el año de 1999:

```{r}
filter(df, year != 1999)
```

#### Condiciones simultáneas

Se puede indicar que se cumplan dos condiciones a la vez mediante el
operador lógico de conjunción, "&". Por ejemplo, filtrar los modelos
manufacturados por *Audi* y fabricados en el año 1999:

```{r}
filter(df, manufacturer == "audi" & year == 1999)
filter(df, manufacturer == "audi", year == 1999)
```

Filtrar los modelos que hayan sido manufacturados por *Audi* o *Dodge*:

```{r}
filter(df, manufacturer == "audi" | manufacturer == "dodge")
```

Se puede plantear de una forma equivalente. Por ejemplo, filtrar las
filas cuyo manufacturador del modelo se encuentre en el conjunto de
nombre: Audi y Dodge,

```{r}
filter(df, manufacturer %in% c("audi","dodge"))
```

# slice() - Extraer filas por su posición

La función `slice()` nos permite filtrar filas de acuerdo a la posición
que ocupan en la tabla. Por ejemplo, filtrar las primeras cinco filas:

```{r}
slice(df, 1:5)
```

Filtrar las filas desde la 20va hasta la 29va:

```{r}
slice(df, 20:29)
```

Filtrar las últimas 10 filas:

```{r}
slice(df, (nrow(df)-9):nrow(df))
```

Seleccionar la primera fila, la 45 y la 100

```{r}
slice(df, c(1,45,100))
```

## 1.6 arrange() - Ordenar filas

La función `arrange()` permite ordenar de forma ascendente o descendente
las filas de acuerdo a las columnas que se especifiquen para ordenarlas.

Si se elige más de una columna, primero ordena la tabla con respecto a
la primera columna; luego, si hay distintos valor asociados a un mismo
valor con respecto a la primera columna escogida para el orden, entonces
ordenará estos datos en el orden especificado en la segunda columna; y
así sucesivamente con el resto de las columnas indicadas para ordenar la
tabla.

Por ejemplo, ordenar la tabla de forma ascedente (orden por defecto) con
respecto al año de manufacturación:

```{r}
arrange(df, year)
```

De forma descendente con respecto al año:

```{r}
arrange(df, desc(year))
```

Ordenar primero por año de forma descendente, luego por el número de
cilindros del modelo y, por último, por el tipo de modelo:

```{r}
arrange(df, desc(year),cyl,class)
```

## 1.7 distintos / unicos valores por fila en la tabla

Para esta subsección, se crea una nueva tabla con duplicados. Primero se
crea un dataframe de tres filas y dos columnas: *nombre* y el *id* del
usuario. Posteriormente, se le concatena a este dataframe su segunda
fila para que se convierta en una tabla con duplicados:

```{r}
df.example <- data.frame(
  id = 1:3,
  nombre = c("Anton","Anthony","Acomo")
)
# Concatenar la segunda fila
df.example <- bind_rows(df.example, slice(df.example,2))
# Ordenar la tabla con respecto a la columna id de forma ascendente
df.example <-  arrange(df.example, id)
print(df.example)
```

### distinct() - Obtener solo los valores únicos o distintos

La función `distinct()` devuelve solo las filas que son distintas entre
sí con respecto a las columnas de referencia, es decir, elimina los
duplicados. Por ejemplo, eliminar la fila duplicada de la tabla
`df.example`, es decir, Anthony con id igual a 2:

```{r}
distinct(df.example)
```

Se crea una tabla similar a la anterior, pero ahora contine una columna
con el color favorito de la persona en cuestión.

```{r}
df.example.col <- data.frame(
  id = c(1,2,2,3),
  nombre = c("Anton","Anthony","Acomo","Acomo"),
  color = c("verde","rojo","verde", "verde")
)
# Ordenar la tabla con respecto a la columna id de forma descendente
df.example.col <-  arrange(df.example.col, desc(id))
print(df.example.col)
```

También se pueden obtener los valores distintos con respecto a una o más
columnas en particular, en lugar de obtener las filas únicas con
respecto a toda las columnas de la tabla. Por ejemplo, obtengamos los
valores únicos de la columna de colores:

```{r}
distinct(df.example.col, color)
```

Ahora, las filas únicas con respecto al nombre y el color:

```{r}
distinct(df.example.col, nombre,color)
```

Consideremos de nuevo la base *mpg*, pero ahora solo las columnas del
fabricante (*manufacturer*) y el modelo (*model*):

```{r}
df.dupl <- select(df, manufacturer, model)
head(df.dupl)
```

Se aprecia que es tabla contiene filas duplicadas por lo que se le
aplicará la función `distinct()` para obtener solo las filas que sean
distintas entre sí:

```{r}
df.no.dupl <- distinct(df.dupl)
head(df.no.dupl)
rm(df.dupl,df.no.dupl)
```

## 1.8 Seleccionar muestras de tablas

En esta sección se empleará funciones que filtran filas de tablas de
forma aleatoria. No obstante, se necesita fijar una *semilla* para que
se puedan replicar los mismos resultados ya que estrictamente una
computadora no puede *aleatorizar*. Si se empleará en un archivo *rmd*
se tiene que poner la semilla en cada chunk donde se busque
replicabilidad.

```{r}
set.seed(567)
```

### sample_n() - Filtrar n filas de forma aleatoria

Esta función obtiene $n$ filas de la tabla aleatoriamente, con y sin
reemplazo. Por ejemplo, obtengamos diez filas de forma aleatoria sin
reemplazo. Con reemplazo se refiere a que una misma fila puede aparecer
más de una vez en la selección.

```{r}
set.seed(567)
sample_n(df, size = 10, replace = FALSE)
```

Repitamos el ejercicio anterior, pero con reemplazo:

```{r}
set.seed(567)
sample_n(df, size = 10, replace = T)
```

### sample_frac() - Filtrar aleatoriamente fracciones de la tabla

Esta función obtiene de forma aleatoria alguna fracción o porcentaje de
las filas de la tabla. Por ejemplo, obtengamos al azar el $10\$$ de las
filas de la tablas y sin reemplazo:

```{r}
set.seed(567)
sample_frac(df, size = 0.1, replace = F)
```

## 1.9 Estadísticas descriptivas y generales de las tablas

### summarise() - Resumen estadístico descriptivo

Esta función aplica funciones de estadística descriptiva a las columnas
de una tabla y genera una nueva con solo las estadísticas calculadas.

Por ejemplo, obtengamos el promedio de los galones por milla en
autopista de todos los modelos en la tanla:

```{r}
summarise(
  df,
  `mean hwy` = mean(hwy)
)
```

Ahora, se va a obtener el número de renglones en la tabla, así como el
número de modelos de coches distintos en toda la tabla\_

```{r}
summarise(
  df,
  rows = n(),
  `nr models` = n_distinct(model)
)
```

Luego, calculemos el mínimo y máximo tanto de las millas por galón en
autopista y ciudad, respectivamente:

```{r}
summarise(df, 
          `min hwy` = min(hwy),
          `min cty` = min(cty),
          `max hwy` = max(hwy),
          `max cty` = max(cty))
```

## 1.10 Agrupamiento de variables

### group_by() - Agrupar datos por variables

Esta función agrupa implícitamente la tabla por una o más columnas. Esto
sirve para aplicar posteriormente operaciones por grupo, como puede ser
con `summarise()`, la cual se aplica a la totalidad de los datos como un
solo grupo, pero al usar `group_by()` las operaciones se aplican a cada
grupo que definen las combinación de una o más variables, según se
especifique. Los grupos son definidos por los valores únicos de la
columna que define la agrupación o las combinaciones únicas que definen
las columnas por las cuales se está agrupando. Al agrupar no cambia cómo
luce la tabla, pero sí el tipo de dato que este almacena, adicional a
una leyenda de cuántos grupos se identificaron. Por ejemplo, agrupemos
por fabricante:

```{r}
print(df)
group_by(df, manufacturer)
```

### Combinar summarise() & group_by()

Al combinar estas funciones, se pueden obtener estadísticas por grupo.
Por ejemplo, mostremos el número de coches por fabricante que hay en la
tabla:

```{r}
summarise(group_by(df, manufacturer),
          cars = n())
```

Ahora, la media / mínimo / máximo de las millas por hora en autpista
para cada modelo;

```{r}
summarise(group_by(df, model),
          mean_hwy = mean(hwy),
          min_hwy = min(hwy),
          max_hwy = max(hwy))
```

### count() - Contar los renglones por grupos

Nos permite obtener el número de filas que define cada grupo en la tabla
al combinarse con `group_by()`. Esta función coincide con `n()` que se
utilizó en la subsección anterior.

Sin agrupar, obtenemos el número de filas totales en la tabla.

```{r}
count(df)
```

Obtengamos el número de registros en la tabla que define cada modelo

```{r}
count(group_by(df, model))
```

También se puede relaizar indicándole la columna para sacar el conteo de
los valores de observaciones por cada valor distinto.

```{r}
count(df, manufacturer)
```

Reiniciemos nuestro dataframe, así como borrar los objetos que hay en
memoria.

```{r}
rm(list = ls())
df <- mpg
```

## 1.11 %\>% - Operador pivotal

Este operador permite encadenar funciones a un mismo objeto sin
necesidad de especificar a qué objeto aplicar cada función como lo
estábamos haciendo antes. Cada paso es ejecutado en un *pipeline*.

Por ejemplo, contemos el número de coche donde el fabricante sea *audi*:

```{r}
df %>%
  filter(manufacturer == "audi") %>%
  count()

# Equivalente a
# count(filter(df,manufacturer == "audi"))
```

Filtrar los fabricantes que sean de *dodge* o *chevrolet*, luego
selecionar las columnas de fabricante, modelo, año y clase.

```{r}
df %>%
  filter(manufacturer %in% c("dodge","chevrolet")) %>%
  select(manufacturer, model, year, class)
```

Calculemos el promedio de millas en autopista por galón y número de
carros por combinación de fabricante, modelo, clase y tipo de
transmisión, posteriormente se tiene que filtrar los promedio mayores a
30 y mostrar los resultados en orden descendente de acuerdo al promedio
al promedio de las millas en autopista por galón.

```{r}
df %>%
  group_by(manufacturer, model, class, trans) %>%
  summarise(
    `mean hwy` = mean(hwy),
    cars = n()
  ) %>%
  ungroup() %>%
  filter(`mean hwy` > 30) %>%
  arrange(desc(`mean hwy`))

# Equivalente a:
# arrange(filter(ungroup(summarise(group_by(df, manufacturer, model, class, trans),`mean hwy` = mean(hwy), cars = n())),`mean hwy` > 30),desc(`mean hwy`))
```

# 1.12 pivoting - Convertir tablas de formato long a wide y viceverse

Consideremos la siguiente tabla que contiene las siguientes columnas:

-   *id*: Identificador del tipo,
-   *type*: tipo y
-   *count*: conteo de los tipos identificados.

```{r}
table.long <- data.frame(
  id = 1:6,
  type = c("a", "b", "a", "c", "c", "a"),
  count = c(20, 50, 45, 15, 12, 5)
)

table.long
```

# pivot_wider() - Convertir datos de formato long a wide

Hay veces en las que quisiéramos que nuestras variables de interes no
estuvieran condensadas en una sola columna como en el caso del tipo en
la tabla de arriba; en su lugar, deseariamos ver la información más
desagregada en la misma tabla como separar columnas por cada entidad
distinta de nuestra variable de interés (para esos casos suelen ser
variables categóricas) como tipo, es decir, que *a*, *b* y *c* tengan su
propia columna. Cada *tipo* en su propia columna.

En estos casos, se suele utilizar la función `pivot_wider()` para
realizar esta tarea de forma eficiente. Se le indica qué columna se va a
desagregar y la columna de dónde tomará los valores de referencia para
entidad única de la variable de interés.

Por ejemplo, transformemos a formato wide el dataframe *table.long*
donde cada entidad única en tipo (*type*) tendrá su propia columna con
los valores de su conteo (*count*).

```{r}
table.wide <- pivot_wider(
  table.long,
  names_from = type,
  values_from = count #,
  #values_fill = 0 # Rellena los NA con el número 0
)

table.wide
```

# pivot_longer() - Convertir datos de formato wide a long

A veces, queremos hacer el proceso inverso que se describió en la
subsección anterior, es decir, querer consdensar distintas columnas que
pertenecen a entes similares entre sí. En este caso, se tienen que
indicar las columnas que se condesarán, el nombre que tendrá la columna
que indicará el nombre de estas entidades, el nombre que tendrá la
columna que mostrará los valores de estas entidades y, por último,
indicar si se van a omitir los casos *NA*.

Trataremos de regresar a la tabla original, *table.long*,
adicionalmente, veamos la diferencia entre considerar o no los casos
*NA*. Primero, consideremos esos casos.

```{r}
table.long1 <- pivot_longer(
  table.wide,
  cols = c("a", "b", "c"),
  names_to = "type 2",
  values_to = "count 2",
  values_drop_na = F
)

table.long1
```

Ahora, omitamos los casos *NA* para obtener la misma tabla al inicio de
esta sección, *table.long*:

```{r}
table.long2 <- pivot_longer(
  table.wide,
  cols = c("a","b","c"),
  names_to = "type",
  values_to = "count",
  values_drop_na = T
)
table.long2
```

### Ejercicio con la tabla de coches

Para este ejercicio, primero filtraremos las tabla para considerar solo
a los fabricantes que sean *jeep*, *land rover* o *hyundai*; luego,
seleccionar las columnas de modelo, tipo de transmisión y galones por
millas de carretera; calcular el promedio de los galones por millas de
autopista para cada modelo y tipo de transmisión; esta será nuestra
tabla en formato long.

```{r}
df.long <- df %>%
  filter(manufacturer %in% c("jeep","land rover", "hyundai")) %>%
  select(model, trans, hwy) %>%
  group_by(model, trans) %>%
  summarise(
    `mean hwy` = mean(hwy)
  ) %>%
  ungroup()

print(df.long)
```

Ahora, convirtamos a formato wide el dataframe anteiror, donde cada
elemento único del tipo de transmisión definirá una columna por sí
misma.

```{r}
df.wide <- df.long %>%
  pivot_wider(
    names_from = trans,
    values_from = `mean hwy`
  )
df.wide
```

Convirtamos de regreso la tabla *df.wide* a formato long

```{r}
df.long1 <- df.wide %>%
  # Se excluyen la columna de modelo puesto que el resto de columnas corresponden al tipo de transmisión
  pivot_longer(
    -model,
    names_to = "trans",
    values_to = "mean hwy",
    values_drop_na = T
    )
df.long1
```

# 1.13 - Seperar y unir columnas

Para esta sección crearemos una tabla que contenga fechas diarias que
empiecen desde el primero de enero del 2021 hasta el 31 de diciembre del
mismo año.

```{r}
# Generamos la secuencia de fechas diarias
dates <- seq.Date(
  from = as.Date("2021-01-01"),
  to = as.Date("2021-12-31"),
  by = "day"
)
table <- data.frame(date = dates)
table %>% head(); table %>% tail()
```

## separate() - Separar alguna columna en múltiples columnas

Esta función nos permite separar alguna columna en más de al separar el
contenido de la columna con respecto a algún patrón.

Por ejemplo, separemos la columna de fecha en las siguientes columnas:
year, mes y día, el patrón de referencia es "-".

```{r}
table.sep <- table %>%
  separate(data = ., # En este caso no es necesario especificar la data puesto que está el pipe
           col = date,
           into = c("year","month","dayofmonth"),
           sep = "-") %>%
  arrange(year, month, dayofmonth)

head(table.sep)
```

Sin embargo, los números que corresponden a los meses y día del mes no
poseen el formato adecuado. Por lo cual, esto se solventa al tranformar
esas columnas a tipo numérico ya que este proceso elimina los ceros a la
izquierda.

```{r}
table.sep <- table %>%
  separate(data = ., # En este caso no es necesario especificar la data puesto que está el pipe. El punto indica que se trabajará con la tabla que se le aplicó el operador `pipeline`
           col = date,
           into = c("year","month","dayofmonth"),
           sep = "-") %>%
  mutate(
    month = as.numeric(month),
    dayofmonth = as.numeric(dayofmonth)
  ) %>%
  arrange(year, month, dayofmonth)
head(table.sep)
```

A continuación, se construirá una tabla para dar otro ejemplo de cómo
aplicar la función `separate()`, con otro caracter como separador, " ,
".

```{r}
# Generamos la secuencia de fechas diarias
ejemplo.separar <- data.frame(
  id = 1:4,
  letras = c("A , B","B , C","C , D","D , E")
)

ejemplo.separar
```

Se separa la columna *letras* en dos columnas.

```{r}
ejemplo.separar %>%
  separate(
    data = ., # En este caso no es necesario especificar la data puesto que está el pipe
    col = letras,
           into = c("Primera letra","Segunda letra"),
           sep = " , ")
```

Este código se puede simplificar al usar `across()` y `mutate()`:

```{r}
table.sep <- table %>%
  separate(data = ., # En este caso no es necesario especificar la data puesto que está el pipe. El punto indica que se trabajará con la tabla que se le aplicó el operador `pipeline`
           col = date,
           into = c("year","month","dayofmonth"),
           sep = "-") %>%
  mutate(across(
    c("month","dayofmonth"),
    ~.x %>% as.numeric() #es equivalente a escribir ~as.numeric(.x)
  )) %>%
  arrange(year, month, dayofmonth)
head(table.sep)
```

Antes, se usaban otras funciones como `mutate_at()`. Sin embargo, ya no
se suelen usar puesto que hay funciones como `across()` que también
pueden realizar las tareas de `mutate_at()`, entre otras funciones que
provee la librería de *tidyr*.

```{r}
table.sep.example <- table %>%
  separate(
    data = .,
    col = date,
    into = c("year","month","dayofmonth"),
    sep = "-"
    ) %>%
  mutate_at(
    .tbl = .,  # ¿qué tabla? -> "." indica que es la tabla en el pipeline
    .vars = c("month","dayofmonth"),  # ¿qué variables se les aplicará la función?
    .funs = as.numeric  # ¿qué función se aplicará?
  ) %>%
  arrange(year,month,dayofmonth)
tail(table.sep.example)
```

## unite() - Combina múltiples columnas en una sola

Esta función hace la tarea contraria a `separate()` puesto que ahora
combinamos distintas columnas en una sola, en lugar de separarlas. Como
ejemplo, regresaremos la tabla de la subsección anterior (*table.sep*) a
la tabla original (*table*).

```{r}
# install.packages("stringr") library(stringr)

# Para añadir los ceros a la izquierda en las columnas de mes y día, se instalará la librería `stringr`
#install.packages("stringr")
library(stringr)

table.unite <- table.sep %>%
  # Añadir los ceros a la izquierdad, en orden, se tienen que especificar los siguientes parámetros: columna que se modificará, el tamaño que tendrá cada texto dentro de la columna, de qué lado se agregará texto y, por último, qué texto se va a agregar
  mutate(
    month = str_pad(month, width=2, side="left", pad="0"),
    dayofmonth = str_pad(dayofmonth, width=2, side="left", pad="0")
  ) %>%
  unite(
    # data = ., No es necesario especificar qué datos se ocupan puesto que toma los datos del pipeline
    col = "date",
    year,month,dayofmonth,
    sep="-"
  ) %>%
  arrange(date)
head(table.unite)
```

De manera análoga a la subsección anterior, se puede hacer de manera más
eficiente con `across()` o `mutate_at()`. Lo realizaremos con la primera
opción.

```{r}
table.unite <- table.sep %>%
  mutate(across(
    c("month","dayofmonth"),
    ~.x %>% str_pad(width=2, side="left", pad="0")
  )) %>%
  unite(
    col = "date",
    year,month,dayofmonth,
    sep = "-"
  ) %>%
  arrange(date)
head(table.unite)
```

El ejemplo anterior con `mutate_at()` queda de la siguiente forma:

```{r}
table.unite <- table.sep %>%
  mutate_at(
    vars(month, dayofmonth),
    ~ str_pad(.x, width = 2, side = "left", pad = "0")
  ) %>%
  unite(
    col = "date",
    year, month, dayofmonth,
    sep = "-"
  ) %>%
  arrange(date)

head(table.unite)
```

# 1.14 dplyr & tidyr en acción

## pull() - Extraer elementos como vector

Esta función permite extraer columnas de un dataframe como vector. Por
ejemplo, obtengamos la columna de galones por milla de autopista:

```{r}
hwy.lista <- df %>% pull(hwy)
cat("Tipo de dato: ", hwy.lista %>% class(), "\n")
hwy.lista
```

En el ejemplo anterior, se indicó en el parámetro de la función `pull()`
la columna a extraer. Sin embargo, también se puede filtrar con
`select()`; no es que una forma de hacerlo sea mejor que la otra, sino
que se usan dependiendo de lo que se quiera hacer puesto que hay casos
donde una forma simplifica más el trabajo que la otra o se ve más
legible el código como veremos en el ejemplo del entero que se extrae de
la primera fila de la columna *hwy*.

```{r}
hwy.lista <- df %>% select(hwy)
cat("Tipo de dato: ", hwy.lista %>% class())
hwy.lista
rm(hwy.lista)
```

En el siguiente ejemplo se extrae el valor de la primera fila de la
misma columna del ejemplo anterior.

```{r}
hwy.integer <- df %>% select(hwy) %>% slice(1) %>% pull()
print("La tabal como un dataframe 1x1 \n")
df %>% select(hwy) %>% slice(1)

cat("Valor en la primera fila: ",hwy.integer,"\nTipo de dato: ", hwy.integer %>% class(),"\n")
print(hwy.integer)
rm(hwy.integer)
```

## Combinar mutate() & group_by()

Al combinar estas funciones, calcular estadísticas por grupo sin perder
o resumir la estructura de la tabla original, a diferencia de
`summarise()` que solo regresa las estadísticas calculadas al combinarse
con `group_by()` y una única fila por cada grupo distinto, al usar
`mutate()` se conservan todos los registros originales.

Por ejemplo, obtengamos el promedio de los galones por milla en
autopista de cada fabricante-modelo distinto:

```{r}
cat("Dimensiones antes de obtener el promedio: ",dim(df),"\n")
df <- df %>%
  group_by(manufacturer,model) %>%
  mutate(
    `mean hwy` = mean(hwy)
  ) %>%
  ungroup()
print(df %>% select(`mean hwy`,everything()))
cat("\nDimensiones después de obtener el promedio: ",dim(df))
```

## case_when() - case when statements

A partir de esta función se puede crear columnas condicionales, es
decir, que el contenido de esta columna se construye a partir del valor
de otras columnas o valores que cumplen ciertas condiciones o casos.

Algunas aplicaciones pueden ser en crear una columna de categorías o
grupos de valores asociados a los valores de otras columnas; crear una
columna numérica que aplique distintas operaciones matemáticas a partir
de otra columna, donde las aplicaciones se aplicarán según el valor del
número; etc.

Por ejemplo, obtengamos una nueva columna, `transmission type`, que diga
el tipo de transmisión, es decir, si es automática o manual. Para este
ejemplo, crearemos una columna auxiliar, `trans_`, que contiene solo el
primer caracter de los datos en la columna de las transmisión.

```{r}
df <- df %>% 
  # Extrae la primera letra de las entradas de la columna trans
  mutate(
    trans_ = str_sub(string = trans, start = 1, end = 1)
  ) %>% 
  mutate(
    `transmission type` = case_when(
      trans_ == "a" ~ "automatic",
      trans_ == "m" ~ "manual",
      TRUE ~ "NA"
    )
  ) %>%
  select(-trans_)

df %>% count(`transmission type`, trans)
```

`TRUE ~ "NA"` indica que será asignado un `NA` en caso de que ningún
valor de la columna `trans_` sea igual a *a* o *m*.

Podemos añadir un id general para identificar los carros a lo largo de
toda la tabla con la función `row_number`, esta función devuelve el
número de renglón que ocupa la observación, es útil para construir
rangos.

```{r}
# id not considering groups
df <- df %>%
  mutate(
    `car id` = row_number()
  )
print(df)
```

Asimismo, con la función `group_by` se puede crear un id para los
carros, pero que solo sirva para identificarlos por fabricante y no a lo
largo de toda la base de datos.

```{r}
# id consudering groups (per manufacturer)
df <- df %>%
  group_by(manufacturer) %>%
  mutate(
    `car id1` = row_number()
  ) %>%
  ungroup()

print(df)
```

```{r}
# id consudering groups (per manufacturer)
df %>%
  summarise(
    `mean hwy` = mean(hwy)
  )
```

```{r}
# id consudering groups (per manufacturer)
df %>%
  group_by(manufacturer) %>%
  summarise(
    `mean hwy` = mean(hwy)
  ) %>%
  ungroup()
```

# Reframe()

La función `reframe()` en **R**, perteneciente al paquete `dplyr`, se
utiliza para reconstruir un nuevo dataframe a partir de operaciones
sobre grupos definidos por `group_by()`, permitiendo que cada grupo
devuelva **una o más filas**.

A diferencia de `mutate()`, que **modifica o agrega columnas sin alterar
el número de filas del dataframe original**, `reframe()` puede **cambiar
el número de filas por grupo** en función del resultado de las
operaciones aplicadas.

También se diferencia de `summarise()`, en que esta última siempre
colapsa cada grupo en **una sola fila** agregada, mientras que
`reframe()` ofrece mayor flexibilidad al permitir operaciones que
generan **múltiples filas por grupo**.

Esto la hace ideal para tareas como:

-   Expandir listas
-   Replicar observaciones
-   Generar resultados detallados por grupo que van más allá de simples
    agregaciones

Repitamos alguno de los ejemplos que hemos visto en esta sección donde
se obtiene el tiempo total de vuelo y distancia recorrida por aerolinea.

```{r}
library(hflights)
df <- hflights

df %>%
  group_by(UniqueCarrier) %>%
  summarise(
    `Tiempo de vuelo` = sum(AirTime, na.rm = T),
    Distancia = sum(Distance)
  )
```

con `reframe()` se obtiene el mismo resultado

```{r}
df %>%
  group_by(UniqueCarrier) %>%
  reframe(
    `Tiempo de vuelo` = sum(AirTime, na.rm = T),
    Distancia = sum(Distance)
  )
```

Sin embargo, también se pueden obtener resultados parecidos a
`transmutate con across`

```{r}
df %>%
  group_by(UniqueCarrier) %>%
  reframe(
    `Número de fila por aerolinea` = paste(UniqueCarrier, TailNum, sep = " - ")
  )
```

# Across()

Hemos empleado esta función desde apartados previos y sabemos, en
general, para qué funciona, para aplicar una o más cálculos a un
conjunto de coluymnas. La sintaxis es la siguiente:

```         
across(.cols, .fns, .names = NULL)
```

donde

| Argumento | Descripción                                                                                                                              |
|-------------|-----------------------------------------------------------|
| `.cols`   | Columnas a transformar. Puede usarse `where()`, `starts_with()`, nombres directos, etc.                                                  |
| `.fns`    | Función o funciones a aplicar. Puede ser una función como `log`, una fórmula como `~ .x * 100`, o una lista de funciones.                |
| `.names`  | (Opcional) Especifica el nombre de las nuevas columnas. Usa `"col"` como plantilla, por ejemplo: `"{col}_mod"` generará `col1_mod`, etc. |

## reframe() y across()

```{r}
mpg <- ggplot2::mpg

mpg
```

Contar valores únicos en cada columna del datraframe

```{r}
mpg %>% 
  reframe(across(
    .cols = everything(), # qué columnas: todas las columnas
    .fns = n_distinct  # qué función: contar valores distintos/únicos
  ))
```

Calcular medias para columnas *displ*, *cty* y *hwy*. (lista de
columnas):

```{r}
mpg %>% 
  reframe(across(
    c(displ, cty, hwy),
    mean
  ))
```

Calcular la mediana de todas las columnas numéricas. En este caso
usaremos el método *where()*, ya que nos permite seleccionar columnas
basado en alguna condución.

```{r}
mpg %>% 
  reframe(across(
    where(is.numeric),
    median
  ))
```

Calcular valores distintos de columnas de tipo texto

```{r}
mpg %>% 
  reframe(across(
    where(is.character),
    n_distinct
  ))
```

## Aplicar múltiples funciones

Para aplicar más de una función sobre múltiples columnas se tiene que
indicar cada función dentro de una lista con la siguiente notación

```         
list(
  fn_col1 = ~function1(.x, resto de parámetros),
  fn_col2 = ~function2(.x, resto de parámetros),
  ...
  fn_colN = ~functionN(.x, resto de parámetros)
)
```

Calcular media y mediana de todas las columnas numéricas

```{r}
mpg %>% 
  reframe(across(
    .cols = where(is.numeric),
    .fns = list(
      avg = ~mean(.x, na.rm = T),
      med = ~median(.x, na.rm = T)
    )
  ))
```

También se puede hacer lo anterior creando la lista previamente

```{r}
avgmed <- list(
  avg = ~mean(.x, na.rm = T),
  med = ~median(.x, na.rm = T)
)

mpg %>% 
  reframe(across(
    where(is.numeric),
    avgmed
  )) 
```

En los ejemplos anteriores se aprecia que el nombre que tiene cada
columna se crea tomando el nombre asociado a *fn_colN* como sufijo, pero
podemos controlar esto mediante el parámetro de *.names*. Cuando solo se
aplica una función, se deja el nombre original de la columna a la que se
le aplica.

-   .fn indica el nombre de la columna *fn_col* que se asoció al cálculo
    de la columna.
-   .col es el nombre de la columna original

```{r}
mpg %>% 
  reframe(across(
    where(is.numeric),
    avgmed, 
    .names = "{.fn}:{.col}" # El nuevo nombres es el nombre asociado al cálculo seguido de ":" y luego del nombre original de la columna
  ))
```

Se puede usar múltiples condiciones dentro de un where. Por ejemplo,
cálculemos la mediana de las columnas que sean numéricas y cuyo nombre
termine con *y*.

```{r}
mpg %>% 
  summarise(across(
    where(is.numeric) & ends_with("y"),
    median
  ))
```

## reframe(), group_by() y across()

Calcular la suma de todas las columnas numéricas desglosado por modelo
de auto

```{r}
mpg %>% 
  group_by(model) %>% 
  reframe(across(
    where(is.numeric),
    sum
  ))
```

Calcular la media de columnas seleccionadas desglosado por fabricante y
modelo

```{r}
mpg %>% 
  group_by(manufacturer, model) %>% 
  reframe(across(
    c(displ, cty, hwy),
    mean
  ))
```

## mutate() & across()

Redondear hacia arriba todas las columnas numéricas. También se puede
adoptar la notación explícita para aplicar las funciones a las columnas,
independientemente de si se quiere aplicar una o más funciones. Por
ejemplo, se aplica la función techo para rendondear hacia arriba
cualquier columna numérica.

```{r}
mpg %>% 
  mutate(across(
    where(is.numeric),
    ~ceiling(.x)
  ))
```

Convertir a mayúsculas todas las columnas de texto

```{r}
mpg %>% 
  mutate(across(
    where(is.character),
    ~str_to_upper(.x)
  ))
```

Se puede aplicar la funci\[on techo y luego elevar al cuadrado el
término resultante usando la notación explícita y el operador pipe, cabe
aclarar que solo se usa un *\~* por cada columna que se creará

```{r}
mpg %>% 
  mutate(across(
    where(is.numeric),
    ~ (.x %>% ceiling())^2
  ))
```

Usando la notación sin el pipe

```{r}
mpg %>% 
  mutate(across(
    where(is.numeric),
    ~ (ceiling(.x))^2
  ))
```

Ahora, a las columnas de texto se convierten a mayúscula y se completan
las entradas a una longitud de 15 caractéres usando el símbolo "-" y por
la derecha

```{r}
mpg %>% 
  mutate(across(
    where(is.character),
    ~.x %>% str_to_upper() %>% str_pad(5, "right", "-")
  ))
```

Sin el operador pipe se vuelve complicado de leer conforme más funciones
anidadas se tengan

```{r}
mpg %>% 
  mutate(across(
    where(is.character),
    ~str_pad(str_to_upper(.x),5, "right", "-")
  ))
```

## mutate() \~ group_by() & across()

Calcular la media de todas las columnas numéricas, excepto *year*, por
fabricante de auto y agregar el sufijo *avg_manufacturer* a las nuevas
columnas calculadas.

```{r}
mpg %>% 
  group_by(manufacturer) %>% 
  mutate(across(
    where(is.numeric) & -year,
    ~mean(.x, na.rm = T),
    .names = "{.col}_avg_manufacturer"
  )) %>% 
  ungroup()
```

# if_any() / if_all() con filter()

Es análogo a la función *across*, pero se dividen en dos casos

-   if_any() : conserva filas donde la condición es verdadera para al
    menos una de las columnas seleccionadas
-   if_all() : conserva filas donde la condición es verdadera para todas
    las columnas seleccionadas

Estas funciones nos sirven para aplicar una o más condiciones a las
filas de un conjunto de columnas a la vez.

Para este apartado, se usará la base de datos de *Star Wars* con la
descripción física de los personajes de las películas.

```{r}
starwars <- dplyr::starwars 
starwars
```

Con el operador *?* se puede consultar la documentación de la función

```{r}
?starwars
```

Filtrar filas donde al menos una columna no tenga NA

```{r}
starwars %>% 
  filter(if_any(
    .cols = everything(),
    .fns = ~ !is.na(.x)
  ))
```

Filtrar filas donde todas las columnas no tengan NA

```{r}
starwars %>% 
  filter(if_all(
    .cols = everything(),
    .fns = ~ !is.na(.x)
  ))
```

Filtrar filas donde "cty" o "hwy" sean mayores a 20. Para esto, usaremos
la notación explícita de función, como en across.

```{r}
mpg %>% 
  filter(if_any(
    c(cty, hwy),
    ~ .x > 20
  )) 
```

También se puede simplificar de la siguiente manera, sin el parámetro
*x*.

```{r}
mpg %>% 
  filter(if_any(
    c(cty, hwy),
    ~ . > 20
  ))
```

Filtrar filas donde "cty" y "hwy" sean mayores a 20

```{r}
mpg %>% 
  filter(if_all(
    c(cty, hwy),
    ~ . > 20
  )) 
```

Filtrar filas donde "cty" y "hwy" sean mayores a 20, pero menores a 30

```{r}
mpg %>% 
  filter(if_all(
    c(cty, hwy),
    ~ .x > 20 & .x < 30
  )) 
```

## Información de vuelos

Para los siguientes ejemplo se utilizará una base de datos que tiene
información detallada sobre vuelos. Para esto, se tiene que cargar la
librería `hflights`

```{r}
library(hflights)

df <- hflights
head(df)
```

Contemos el número de filas y columnas que tiene la base de datos

```{r}
cat("El número de vuelos registrados es: ",nrow(df), "vuelos, mientras que tiene un total de ",ncol(df), " columnas.")
```

También, se cuentan el número de vuelos distintos que hay en la tabla de
vuelos

```{r}
df %>%
  count(UniqueCarrier, FlightNum, TailNum, Year, Month, DayofMonth)
```

Columnas que empiezan con la palabra "Taxi"

```{r}
df %>%
  select(starts_with("Taxi"))
```

Veamos cuántos vuelos hubieron con una distancia menor a las mil millas
mayor o igual que mil millas. Para esto, creamos una categoría para los
vuelos dependiendo de la distancia que recorrieron y luego contamos los
vuelos por categoría.

```{r}
df %>%
  mutate(
    dist1000 = case_when(
      Distance < 1000 ~ "Distancia < 1000",
      Distance >= 1000 ~ "Distancia >= 1000"
    )
  ) %>%
  count(dist1000)
```

Ahora, contemos el número de vuelo por aerolinea y ordenemos el conteo
de mayor a menor, El nombre por defecto que se crea en la columna de
conteo es *n*.

```{r}
df %>%
  group_by(UniqueCarrier) %>%
  count() %>%
  ungroup() %>%
  arrange(desc(n))
```

Por otro lado, obtengamos el número de vuelos por aerolínea que fueron
cancelados de mayor a menor. Si el vuelo fue cancelado, la columna
`Cancelled` tendrá un valor igual a 1.

Para este ejemplo, asociaremos un nombre de distinto a la columna de
conteo, *Vuelos cancelados*; se indica el nombre mediante el parámetro
*name*.

```{r}
df %>%
  filter(Cancelled == 1) %>%
  group_by(UniqueCarrier) %>%
  count(name = "Vuelos cancelados") %>%
  ungroup() %>%
  arrange(desc(`Vuelos cancelados`))
```

A continuación, calcularemos el porcentaje de vuelos cancelados por
aerolínea

```{r}
df %>%
  group_by(UniqueCarrier,Cancelled) %>%
  count(name = "Número de vuelos") %>%
  ungroup() %>%
  group_by(UniqueCarrier) %>%
  mutate(
    Porcentaje = 100 * round(`Número de vuelos` / sum(`Número de vuelos`), 4)
  ) %>%
  ungroup() %>%
  filter(Cancelled == 1)
```

Creemos una columna fecha en formato "Año-mes-día". Sin embargo, en las
fechas el mes y el día tienen siempre dos dígitos, es decir, nunca vemos
una fecha *1899-1-22*, sino *1899-01-22*.

```{r}
df %>% select(Year,Month,DayofMonth)
```

Por lo tanto, ocuparemos de la función `str_pad()` para realizar esta
tarea, se le tiene que indicar la columna a la que se le aplicará esta
función, cuántos caracteres tiene que tener cada una de las entradas de
la columna, si se acompletarán los caracteres por la izquierda o
derecha, y el texto con el que se completarán las entradas de la
columna. Asimismo, se empleará la la función `across()` con `mutate()`
para aplicar la función `str_pad()` a más de una columna a la vez.

A continuación se aplican las funciones anteriormente descritas arriba
para construir la columna de fechas

```{r}
df %>%
  mutate(across(
    .cols = c("Month","DayofMonth"), # Columnas a las que se le aplicará la función
    .fns = ~ str_pad(.x, 2,"left", "0") # Función que se aplicará
  )) %>%
  unite(
    col = "Fecha",
    Year,Month,DayofMonth,
    sep="-"
  )
```

Ahora, obtengamos el número de vuelos, por aerolínea, cancelados de
acuerdo a los códigos de cancelación, `CancellationCode`. Sin embargo,
se puede apreciar que hay códigos de cancelación sin clave

```{r}
df %>%
  count(CancellationCode)
```

Aosicaremos el código *0* a estos vuelos sin código para posteriormente
contar el número de vuelos cancelados por código y aerolínea

```{r}
df_cancelled_carrier <- df %>%
  mutate(
    CancellationCode = case_when(
      CancellationCode == "" ~ "0",
      TRUE ~ CancellationCode
    )
  ) %>%
  group_by(UniqueCarrier,CancellationCode) %>%
  count() %>%
  ungroup()

print(df_cancelled_carrier)
```

En el código anterior se usa `TRUE ~ CancellationCode` para indicar que
en caso de que no ocurra que el valor sea igual al *string* vacío "",
entonces devuelve el mismo valor.

Por último, tenemos que pasar a un formato *wide* para mostar de una
mejor manera los datos por aerolínea. Como no todas las aerolineas
tienen registrados los mismos códigos o siquiera tener vuelos cancelados
con ese código, entonces al pasar la tabla a formato wide, saldrán
valores *NA* por lo que se tendrá que rellenar estos valores con ceros
puesto que indicaría que no hay vuelos cancelados con ese código.

```{r}
df_cancelled_carrier <- df_cancelled_carrier %>%
  pivot_wider(
    names_from = "CancellationCode",
    values_from = "n",
    values_fill = 0
  )

print(df_cancelled_carrier)
```

# Participación de empresas

El siguiente ejemplo muestra cómo obtener la participación en el mercado
de un empresa multiproducto donde nos interesa la particiáción de cada
empresa por producto. Consideremos la siguiente tabla que contiene los
datos sobre las ventas de tres empresas en tres productos distintos.

```{r}
# Crear el dataframe
ventas_df <- tibble(
  empresa = c(
    "Empresa_A", "Empresa_A", "Empresa_A", "Empresa_A",
    "Empresa_B", "Empresa_B", "Empresa_B",
    "Empresa_C", "Empresa_C", "Empresa_C", "Empresa_C"
  ),
  producto = c(
    "Producto_1", "Producto_1", "Producto_2", "Producto_3",  # Empresa_A repite Producto_1
    "Producto_1", "Producto_3", "Producto_3",                # Empresa_B repite Producto_3
    "Producto_1", "Producto_1", "Producto_2", "Producto_4"   # Empresa_C repite Producto_1
  ),
  venta = c(
    1000, 1200, 1500, 2000,  # Montos diferentes para Empresa_A
    1100, 2100, 2200,        # Montos diferentes para Empresa_B
    1300, 1400, 1600, 1800   # Montos diferentes para Empresa_C
  )
)

print(ventas_df)
```

Importe total por empresa y producto

```{r}
ventas_df <- ventas_df %>%
  group_by(empresa,producto) %>%
  # Venta total de producto por empresa
  mutate(
    venta.producto.empresa.total = sum(venta)
  ) %>%
  ungroup() %>%
  # Venta total y media del producto en toda la tabla
  group_by(producto) %>%
  mutate(
    venta.producto.total = sum(venta)
  ) %>%
  ungroup() %>%
  # Participación de la empresa por producto en el mercado
  mutate(participacion.producto = round(100*venta.producto.empresa.total/venta.producto.total,2))
print(ventas_df)
```

# Ejercicios

## Ejercicio 1

En este ejercicio utilizarás el conjunto de datos `hflights` del paquete
`hflights`.

```{r}
# Se guarda la base en una variable 'df'
df <- hflights
head(df)
```

Usa `dplyr` y `tidyr` para responder las siguientes preguntas:

-   ¿Cuántas filas y columnas tiene la tabla `hflights`?

```{r}
# Se puede hacer con la funci[on dim
cat("La tabla tiene ", nrow(df) ," filas y ", ncol(df) ," columnas.")
```

-   ¿Cuántos aerolíneas (carriers) distintos aparecen en la tabla?
    (Imprime una tabla con los nombres de los aerolíneas distintos).

```{r}
# Se puede hacer con la funci[on dim
cat("Hay ", nrow(df %>% distinct(UniqueCarrier))," aerolineas distintas.")

df %>% 
  distinct(UniqueCarrier)
```

-   ¿Cuáles y cuántos aeropuertos estuvieron involucrados? ¡Considera
    tanto los aeropuertos de origen como los de destino!

```{r}
# Aeropuertos distintos, considerando origen y distinto
aeropuertos <- bind_rows(
  df %>% select(Aeropuerto = Origin),
  df %>% select(Aeropuerto = Dest)
) %>%
  distinct() %>%
  arrange(Aeropuerto)
head(aeropuertos)

cat("Estuvieron involucrados ", nrow(aeropuertos), " aeropuertos distintos.")
```

Hay otra solución usando los operadores pivotales, la cual es más
general

```{r}
df %>% 
  select(Origin, Dest) %>% 
  distinct() %>% 
  pivot_longer(
    cols = everything(),
    names_to = "orig/dest",
    values_to = "airport"
  ) %>% 
  distinct(airport) %>% 
  arrange(airport) %>%
  nrow()

# Hay otra solución basada en operaciones con listas:
c(df$Origin, df$Dest) %>% unique() %>% sort %>% length()
```

-   ¿Cuántos vuelos fueron cancelados?

```{r}
cancelados <- df %>%
  filter(Cancelled == 1)

cat("Se cancelaron ", nrow(cancelados)," vuelos.")
```

## Ejercicio 2

### Primera parte:

Produce una tabla con las siguientes estadísticas por aerolínea:

-   Número de vuelos por aerolínea
-   Distancia total volada (en millas) por aerolínea
-   Tiempo total real transcurrido (en horas) por aerolínea
-   Tiempo total en el aire (en horas) por aerolínea
-   Distancia promedio por vuelo para cada aerolínea
-   Tiempo promedio real transcurrido (en horas) por vuelo para cada
    aerolínea
-   Tiempo promedio en el aire (en horas) por vuelo para cada aerolínea

```{r}
# Si notamos en la tarea, todas las estad[isticas son por vuelo
df.summary <- df %>% 
  group_by(UniqueCarrier) %>%
  reframe(
    `Vuelos por aerolinea por código` = n_distinct(FlightNum, na.rm = TRUE),
    `Vuelos por aerolinea por filas` = n(),
    `Distancia total [millas]` = sum(Distance, na.rm = TRUE),
    `Tiempo total real [horas]` = sum(ActualElapsedTime, na.rm = TRUE) / 60,
    `Tiempo total en aire [horas]` = sum(AirTime, na.rm = TRUE) / 60,
    `Distancia promedio [millas]` = mean(Distance, na.rm = TRUE),
    `Tiempo promedio real [horas]` = mean(ActualElapsedTime, na.rm = TRUE) / 60,
    `Tiempo promedio en aire [horas]` = mean(AirTime, na.rm = TRUE) / 60,
  )

df.summary
```

### Segunda parte:

Calcula el porcentaje de la distancia total volada por los **3
aerolíneas con mejor desempeño** en comparación con la distancia total
volada por los aerolíneas restantes. Ejecuta los siguientes pasos:

1.  Ordena los aerolíneas por distancia total volada.
2.  Agrupa a los 3 con mejor desempeño en un grupo, y a los demás en
    otro grupo.
3.  Para cada grupo, calcula la distancia total volada.
4.  Para cada grupo, calcula el porcentaje:
    $\text{Distancia total volada por grupo} / \text{Distancia total volada por todos los aerolíneas}$

```{r}
df.summary %>%
  arrange(desc(`Distancia total [millas]`)) %>%
  mutate(
    Rank = row_number(),
    Desempeño = case_when(
      Rank > 3 ~ "Desempeño bajo",
      TRUE ~ "Desempeño alto"
    )
  ) %>%
  group_by(Desempeño) %>%
  mutate(
    `Aerolineas por grupo` = n(),
    `Distancia total por grupo de desempeño [millas]` = sum(`Distancia total [millas]`),
    `Distancia por grupo de desempeño %` = round(100 * `Distancia total [millas]` / `Distancia total por grupo de desempeño [millas]`,2)
  ) %>%
  select(
    Rank, Desempeño,
    `Distancia total [millas]`,
    `Distancia total por grupo de desempeño [millas]`,
    `Distancia por grupo de desempeño %`,
    everything()
  )
```

## Ejercicio 3

Modifica tu tabla principal de vuelos (`flights`):

-   Crea una columna de **fecha** uniendo las columnas: `year`, `month`
    y `day`.
-   Al unir las columnas, **no pierdas las columnas originales** (puedes
    duplicarlas con nombres ligeramente distintos antes de ejecutar
    `unite` o con el parámetro *remove = FALSE*).
-   Deberás **parsear** la columna de fecha después de la operación de
    unión.
-   También debes **agregar ceros a la izquierda** en las columnas de
    mes y día antes de crear la fecha.
-   Crea las columnas: **trimestre** (`quarter`) y **semana** (`week`).

> 💡 **Sugerencia**: puedes usar los paquetes del `tidyverse` como
> `lubridate` (para manipulaciones de fecha y hora) y `stringr` (para
> manipulaciones con cadenas de texto). Puedes usar `lubridate` si
> decides no usar `lubridate`: `lubridate` y `lubridate` para obtener
> los trimestres y semana del año.

```{r}
library(lubridate)

df.fechas <- df %>%
  mutate(across(
    c(Month, DayofMonth),
    ~ str_pad(.x, width = 2, side = "left", pad = "0")
  )) %>%
  unite("Fecha", DayofMonth, Month, Year, sep = "/", remove = FALSE) %>%
  mutate(
    Fecha = dmy(Fecha),
    Trimestre = quarter(Fecha),
    Semana = week(Fecha)
  )

df.fechas
```

También se puede hacer mediante la función *paste()* usando *mutate()*

```{r}
df.fechas <- df %>%
  mutate(
    across(
      c(Month,DayofMonth),
      ~str_pad(.x,width = 2, side = "left", pad = "0"),
      .names = "{.col}"
    ),
    Fecha = dmy(paste(DayofMonth, Month, Year, sep = "/")),
    Trimestre = quarter(Fecha),
    Semana = week(Fecha)
  )

df.fechas
```

Usando tu tabla modificada, intenta responder las siguientes preguntas:

-   ¿El número total de vuelos está aumentando o disminuyendo
    **trimestralmente**?

```{r}
df.fechas.trimestre <- df.fechas %>%
  group_by(Trimestre) %>%
  reframe(
    `Vuelos totales` = n_distinct(FlightNum)
  ) %>%
  arrange(Trimestre) %>%
  mutate(
    `Crecimiento en vuelos %` = round(100 * (`Vuelos totales` - dplyr::lag(`Vuelos totales`, 1)) / `Vuelos totales`, 2)
  )

df.fechas.trimestre
```

-   ¿La distancia total volada está aumentando o disminuyendo
    **mensualmente**?

```{r}
df.fechas.mensual <- df.fechas %>%
  group_by(Month) %>%
  reframe(
    `Distancia total` = sum(Distance)
  ) %>%
  arrange(Month) %>%
  mutate(across(
    `Distancia total`,
    ~round(100 * (.x - dplyr::lag(.x, 1)) / .x, 2),
    .names = "Crecimiento en {.col} %"
  ))

df.fechas.mensual
```

-   💡 **Pista**: la función `lag()` de `dplyr` puede ayudarte a
    calcular las diferencias trimestrales o mensuales.

## Ejercicio 4

La idea de este último ejercicio es una tarea de transformación de
datos, en la que deberás usar una técnica llamada **pivotar**. Construye
una tabla que se asemeje a un **mapa de calor** siguiendo estos pasos:

-   Para cada **aerolínea (carrier)** y **mes**, calcula el **número
    total de vuelos**.
-   Luego, **normaliza** el número total de vuelos (divide cada valor
    entre el número máximo de vuelos total; ¡debes obtener valores entre
    0 y 1!).
-   Ahora **pivotea** tu tabla de formato **wyde**.
-   Cada fila debe representar una **aerolínea**, y cada columna un
    **mes**.
-   Los valores en las celdas serán el número **normalizado de vuelos**.

Ejemplo esperado de salida:

| Carrier   | Mes 1 | Mes 2 | ... | Mes 12 |
|-----------|-------|-------|-----|--------|
| Carrier 1 | x1;1  | x1;2  | ... | x1;12  |
| Carrier 2 | x2;1  | x2;2  | ... | x2;12  |
| ...       | ...   | ...   | ... | ...    |
| Carrier n | xn;1  | xn;2  | ... | xn;12  |

Donde `xᵢⱼ` representa el valor **normalizado** del total de vuelos para
la aerolínea `i` en el mes `j`.

```{r}
df.vuelos.mes <- df %>%
  group_by(UniqueCarrier,Month) %>%
  reframe(
    `Vuelos totales` = n_distinct(FlightNum)
  ) %>%
  mutate(
    `Vuelos totales` = `Vuelos totales` / max(`Vuelos totales`)
  ) %>%
  pivot_wider(
    names_from = Month,
    values_from = `Vuelos totales`,
    names_prefix = "Mes "
  )

df.vuelos.mes
```

Visualizando el mapa de calor y usando todos los vuelos por pasajero, es
decir, no nos interesan los códigos de vuelo distintos, sino la cantidad
de registros por aérolinea, se usará `n()`.

```{r}
df %>% 
  select(
    carrier = UniqueCarrier,
    Month
  ) %>% 
  group_by(carrier, Month) %>% 
  reframe(flights = n()) %>%
  ungroup() %>% 
  mutate(`max flights` = max(flights),
         `flights normalized` = flights / `max flights`) %>%
  select(carrier, Month, `flights normalized`) %>% 
  mutate(month = as.factor(Month)) %>% 
  ggplot(aes(x = carrier, 
             y = month,
             fill = `flights normalized`)) +
  geom_tile() +
  scale_fill_viridis_c(option = "magma") +
  theme_minimal()
```
